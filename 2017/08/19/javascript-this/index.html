<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>javascript之this理解 | Kenve's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">javascript之this理解</h1><a id="logo" href="/.">Kenve's Blog</a><p class="description">世界和平(.)</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">javascript之this理解</h1><div class="post-meta">Aug 19, 2017<span> | </span><span class="category"><a href="/categories/Web/">Web</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><p>this作为JavaScript的关键字之一，与其他语言相比表现略有不同，并且，在<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode" target="_blank" rel="external">严格模式</a>和非严格模式下表现也有差别。<br><a id="more"></a></p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul>
<li>函数的调用方式决定了this的值，随着函数调用方式（使用场合）的不同，this的值也会发生变化。但总的来说谁调用指向谁。</li>
<li>this不能在执行期间被赋值。</li>
<li>在每次函数，被调用时this的值也有可能变化。</li>
<li>ES5中引入了<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="external">bind</a>方法用于设置函数的this值,无论这个函数是如何被调用的。</li>
<li>ES6新增了this词法解析的箭头函数（它在闭合的执行上下文内设置this的值）。<br>语法</li>
</ul>
<h2 id="在不同环境下，this的不同用法。"><a href="#在不同环境下，this的不同用法。" class="headerlink" title="在不同环境下，this的不同用法。"></a>在不同环境下，this的不同用法。</h2><h3 id="全局上下文"><a href="#全局上下文" class="headerlink" title="全局上下文"></a>全局上下文</h3><p>在全局运行上下文中（在任何函数体外）调用，this就指向全局对象Global(global/window)。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//在浏览器的执行环境中，this指向全局对象即 window 对象</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>);   <span class="comment">//true </span></div><div class="line"></div><div class="line"><span class="keyword">this</span>.a =<span class="string">'hello'</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a); <span class="comment">//'hello'</span></div><div class="line"><span class="built_in">console</span>.log(a) <span class="comment">//'hello'</span></div></pre></td></tr></table></figure></p>
<h3 id="函数上下文"><a href="#函数上下文" class="headerlink" title="函数上下文"></a>函数上下文</h3><p>在函数内部，this的值取决于函数是如何被调用的。</p>
<h4 id="直接调用"><a href="#直接调用" class="headerlink" title="直接调用"></a>直接调用</h4><p>在非严格模式下，且this值未被call设置，这时this的值默认为全局对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">test()===<span class="built_in">window</span>; <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> b = <span class="number">1</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　<span class="keyword">this</span>.b = <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line">test1();</div><div class="line"><span class="built_in">console</span>.log(b); <span class="comment">//0</span></div></pre></td></tr></table></figure></p>
<p>在严格模式下，如果this未被执行的上下文环境定义（this将保持他进入执行环境时的值），那么它将会默认为undefined。<br>如下：由于test2()是直接被调用的，而不是作为对象的属性/方法调用的（比如 window.f2()），所以this的值是undefined。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="meta">    "use strict"</span>; <span class="comment">//严格模式</span></div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line">test2() ===<span class="literal">undefined</span>; <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<h4 id="对象方法中的this"><a href="#对象方法中的this" class="headerlink" title="对象方法中的this"></a>对象方法中的this</h4><p>函数作为某个对象的方法调用时，这时this就指这个上级对象（调用该函数的对象）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  <span class="attr">prop</span>: <span class="number">22</span>,</div><div class="line">  <span class="attr">f</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.prop;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//调用obj.f()时，函数内的this将绑定到o对象。</span></div><div class="line"><span class="built_in">console</span>.log(obj.f()); <span class="comment">// 22</span></div></pre></td></tr></table></figure>
<p>this的值只与函数 f 作为 o 的成员被调用有关系,在何处或者如何定义调用函数完全不会影响到this的行为。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">var</span> obj = &#123;<span class="attr">prop</span>: <span class="number">22</span>&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">independent</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.prop;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 后定义</span></div><div class="line">obj.f = independent;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(obj.f()); <span class="comment">// 22</span></div></pre></td></tr></table></figure></p>
<p>类似的，this 的绑定只受最靠近的成员引用的影响。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">o.b = &#123;</div><div class="line">  <span class="attr">g</span>: independent,</div><div class="line">  <span class="attr">prop</span>: <span class="number">22</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">// g的上一级时b</span></div><div class="line"><span class="built_in">console</span>.log(o.b.g()); <span class="comment">// 22</span></div></pre></td></tr></table></figure></p>
<h4 id="原型链中的this"><a href="#原型链中的this" class="headerlink" title="原型链中的this"></a>原型链中的this</h4><p>相同的概念在定义在原型链中的方法也是一致的。如果该方法存在于一个对象的原型链上，那么this指向的是调用这个方法的对象，表现得好像是这个方法就存在于这个对象上一样。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//定义o对象 包含f匿名函数，作用时返回a b和</span></div><div class="line"><span class="keyword">var</span> o = &#123;</div><div class="line">  <span class="attr">f</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.a + <span class="keyword">this</span>.b; </div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//  p 继承 o, 使用o的原型对象及其属性去创建一个新的对象p</span></div><div class="line"><span class="keyword">var</span> p = <span class="built_in">Object</span>.create(o);</div><div class="line">p.a = <span class="number">1</span>;</div><div class="line">p.b = <span class="number">4</span>;</div><div class="line"></div><div class="line"><span class="comment">// p调用f</span></div><div class="line"><span class="built_in">console</span>.log(p.f()); <span class="comment">// 5</span></div></pre></td></tr></table></figure>
<p>上例子中，对象p没有属于它自己的f属性，它的f属性继承自它的原型。但是这对于最终在o中找到f属性的查找过程来说没有关系；查找过程首先从p.f的引用开始，所以函数中的this指向p。也就是说，因为f是作为p的方法调用的，所以它的this指向了p。这是JavaScript的原型继承中的一个有趣的特性。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create" target="_blank" rel="external">Object.create()</a></p>
<h4 id="getter-与-setter-中的-this"><a href="#getter-与-setter-中的-this" class="headerlink" title="getter 与 setter 中的 this"></a>getter 与 setter 中的 this</h4><p>谁调用指向谁的概念也适用于函数作为getter、setter调用，作为getter或setter函数都会绑定 this 到从设置属性或得到属性的那个对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//定义</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">modulus</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(<span class="keyword">this</span>.re * <span class="keyword">this</span>.re + <span class="keyword">this</span>.im * <span class="keyword">this</span>.im);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> o = &#123;</div><div class="line">  <span class="attr">re</span>: <span class="number">1</span>,</div><div class="line">  <span class="attr">im</span>: <span class="number">-1</span>,</div><div class="line">  get phase()&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.atan2(<span class="keyword">this</span>.im, <span class="keyword">this</span>.re);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//对象o上定义一个新属性modulus</span></div><div class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">'modulus'</span>, &#123;</div><div class="line">  <span class="attr">get</span>: modulus, <span class="attr">enumerable</span>:<span class="literal">true</span>, <span class="attr">configurable</span>:<span class="literal">true</span>&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(o.phase, o.modulus); <span class="comment">// -0.78 , 1.4142</span></div></pre></td></tr></table></figure></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="external">Object.defineProperty</a></p>
<h4 id="构造函数中的-this"><a href="#构造函数中的-this" class="headerlink" title="构造函数中的 this"></a>构造函数中的 this</h4><p>所谓构造函数，就是通过这个函数生成一个新对象(使用new关键字),它的this与即将被创建的新对象绑定（this就指这个新对象）。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 构造函数的工作方式如下：</div><div class="line"> *</div><div class="line"> * function MyConstructor()&#123;</div><div class="line"> *   // 真正函数体的代码从这里开始.  </div><div class="line"> *   // 在 this 上创建属性，</div><div class="line"> *   // 根据需要分配给他们.  例如,</div><div class="line"> *   this.fum = "nom";</div><div class="line"> *   // 等等...</div><div class="line"> *</div><div class="line"> *   // 如果函数有一个返回语句</div><div class="line"> *   // 返回一个对象, 这个对象将是</div><div class="line"> *   // new 结果的表达式.  除此之外,</div><div class="line"> *   // 表达式的结果是对象</div><div class="line"> *   // 当前对象绑定到 this</div><div class="line"> *   // (即通常看到的通常情况).</div><div class="line"> * &#125;</div><div class="line"> */</div><div class="line"></div><div class="line">　<span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</div><div class="line">     <span class="comment">//this不是全局对象,对外部无影响</span></div><div class="line">　　　<span class="keyword">this</span>.x = <span class="number">1</span>;</div><div class="line">　&#125;</div><div class="line">　<span class="keyword">var</span> o = <span class="keyword">new</span> test();</div><div class="line">　alert(o.x); <span class="comment">// 1</span></div><div class="line">  </div><div class="line">  <span class="comment">// 不改变全局</span></div><div class="line">　<span class="keyword">var</span> x = <span class="number">2</span>;</div><div class="line">　<span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　　<span class="keyword">this</span>.x = <span class="number">1</span>;</div><div class="line">　&#125;</div><div class="line">　 o = <span class="keyword">new</span> test1();</div><div class="line">　alert(x); <span class="comment">//2</span></div><div class="line"></div><div class="line">  <span class="comment">//手动的设置了返回对象，与this绑定的默认对象被取消</span></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">test3</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.x = <span class="number">1</span>;</div><div class="line">  <span class="keyword">return</span> &#123;<span class="attr">x</span>:<span class="number">3</span>&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">o = <span class="keyword">new</span> test3();</div><div class="line"><span class="built_in">console</span>.log(o.x); <span class="comment">//  3</span></div></pre></td></tr></table></figure></p>
<h4 id="call-和-apply"><a href="#call-和-apply" class="headerlink" title="call 和 apply"></a>call 和 apply</h4><p>当一个函数的函数体中使用了this关键字时，通过所有函数都从Function对象的原型中继承的call()方法和apply()方法调用时，它的值可以绑定到一个指定的对象上。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">c, d</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.a + <span class="keyword">this</span>.b + c + d;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> o = &#123;<span class="attr">a</span>:<span class="number">1</span>, <span class="attr">b</span>:<span class="number">3</span>&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 第一个参数是用作“this”的对象，后续参数作为参数传递给函数调用</span></div><div class="line">add.call(o, <span class="number">5</span>, <span class="number">7</span>); <span class="comment">// 1 + 3 + 5 + 7 = 16</span></div><div class="line"></div><div class="line"><span class="comment">// 第一个参数是用作“this”的对象，第二个参数是一个数组，其成员用作函数调用中的参数</span></div><div class="line">add.apply(o, [<span class="number">10</span>, <span class="number">20</span>]); <span class="comment">// 1 + 3 + 10 + 20 = 34</span></div></pre></td></tr></table></figure></p>
<p>注意：如果传递的 this 值不是一个对象，JavaScript 将会尝试使用内部 ToObject（使用相关构造函数） 操作将其转换为对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">this</span>));</div><div class="line">&#125;</div><div class="line"><span class="comment">//通过new Number(7)转换为对象</span></div><div class="line">bar.call(<span class="number">7</span>); <span class="comment">// [object Number]</span></div></pre></td></tr></table></figure>
<h4 id="bind-方法"><a href="#bind-方法" class="headerlink" title="bind 方法"></a>bind 方法</h4><p>ES5中引入了 <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="external">Function.prototype.bind</a>,调用f.bind(someObject)会创建一个与f具有相同函数体和作用域的函数，但是在这个新函数中，this将永久地被绑定到了bind的第一个参数，无论这个函数是如何被调用的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.a;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> g = f.bind(&#123;<span class="attr">a</span>:<span class="string">"azerty"</span>&#125;);</div><div class="line"><span class="built_in">console</span>.log(g()); <span class="comment">// azerty</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> o = &#123;<span class="attr">a</span>:<span class="number">37</span>, <span class="attr">f</span>:f, <span class="attr">g</span>:g&#125;;</div><div class="line"><span class="built_in">console</span>.log(o.f(), o.g()); <span class="comment">// 37, azerty</span></div></pre></td></tr></table></figure></p>
<h3 id="DOM事件处理函数中的-this"><a href="#DOM事件处理函数中的-this" class="headerlink" title="DOM事件处理函数中的 this"></a>DOM事件处理函数中的 this</h3><p>当函数被用作事件处理函数时，它的this指向触发事件的元素（一些浏览器在使用非addEventListener的函数动态添加监听函数时不遵守这个约定）。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 被调用时，将关联的元素变成蓝色</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bluify</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span> === e.currentTarget); <span class="comment">// 总是 true</span></div><div class="line"></div><div class="line">  <span class="comment">// 当 currentTarget 和 target 是同一个对象是为 true</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span> === e.target);        </div><div class="line">  <span class="keyword">this</span>.style.backgroundColor = <span class="string">'#A5D9F3'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 获取文档中的所有元素的列表</span></div><div class="line"><span class="keyword">var</span> elements = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'*'</span>);</div><div class="line"></div><div class="line"><span class="comment">// 将bluify作为元素的点击监听函数，当元素被点击时，就会变成蓝色</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span> ; i&lt;elements.length ; i++)&#123;</div><div class="line">  elements[i].addEventListener(<span class="string">'click'</span>, bluify, <span class="literal">false</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="内联事件处理函数中的-this"><a href="#内联事件处理函数中的-this" class="headerlink" title="内联事件处理函数中的 this"></a>内联事件处理函数中的 this</h3><p>当代码被内联处理函数调用时，它的this指向监听器所在的DOM元素：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"alert(this.tagName.toLowerCase());"</span>&gt;</span></div><div class="line">  Show this</div><div class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></div></pre></td></tr></table></figure>
<p>上面的alert会显示button。注意只有外层代码中的this是这样设置的：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"alert((function()&#123;return this&#125;)());"</span>&gt;</span></div><div class="line">  Show inner this</div><div class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></div></pre></td></tr></table></figure>
<p>在这种情况下，没有设置内部函数的 this，所以它指向 global/window 对象（即非严格模式下调用的函数未设置 this 时指向的默认对象）。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">onclick</span>=<span class="string">"alert(this);"</span>&gt;</span></div><div class="line">  Show this</div><div class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- 弹出 url+# 并跳转--&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:;"</span> <span class="attr">onclick</span>=<span class="string">"alert(this);"</span>&gt;</span></div><div class="line">  Show this</div><div class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- 弹出  javascript:;--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://www.baidu.com"</span> <span class="attr">onclick</span>=<span class="string">"alert(this);"</span>&gt;</span></div><div class="line">  Show this</div><div class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- 弹出 https://www.baidu.com 并跳转--&gt;</span></div></pre></td></tr></table></figure>
<p>使用a标签时弹出 href 的值，即this 为href的值。</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="//kenve.github.io/2017/08/19/javascript-this/" data-id="cj6qn638a00001kdvzfbtjb57" class="article-share-link">分享</a><div class="tags"><a href="/tags/javascript/">javascript</a></div><div class="post-nav"><a href="/2017/04/26/hello-world/" class="next">Tests</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="//kenve.github.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Web/">Web</a><span class="category-list-count">5</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/随笔/" style="font-size: 15px;">随笔</a> <a href="/tags/javascript/" style="font-size: 15px;">javascript</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/html5/" style="font-size: 15px;">html5</a> <a href="/tags/react/" style="font-size: 15px;">react</a></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017 <a href="/." rel="nofollow">Kenve's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>